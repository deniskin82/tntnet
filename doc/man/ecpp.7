.\" Copyright (C) 2006 Tommi Maekitalo
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.TH ecpp 7 2006-07-23 "Tntnet" "Tntnet users guide"
.
\" =====================================================================
.SH NAME
\" =====================================================================
.
ecpp \- template-language for tntnet (8)
.
\" =====================================================================
.SH DESCRIPTION
\" =====================================================================
.
.B Ecpp
is the template-language used by the tntnet-system to generate dynamic content.
.PP
A template consists of normal content (normally html-data) enriched with special
tags, which trigger some special handling.
.PP
One ecpp-file is compiled into a C++-class.
The C++-class is placed into the namespace
.B component.
A ecpp-file compiled into a C++-class is called
.B component.
The name of the class is the basename of the file.
.
\" ---------------------------------------------------------------------
.SS request, reply, qparam
\" ---------------------------------------------------------------------
Each component has 3 parameters: \fIrequest\fP, \fIreply\fP and \fIqparam\fP.
.br
\fIrequest\fP holds information about the client-request like http-headers
and the url, but also additional parameters specified in the config-file
\fItntnet.conf(7)\fP.
The type of \fIrequest\fP is \fItnt::HttpRequest\fP.
.PP
\fIreply\fP receives the answer from the component. The component
can set additional http-headers here, set cookies and \- most important \-
generate output.
The most important methods here are \fIreply.out()\fP and \fIreply.sout()\fP.
Both return a std::ostream, which receives the output of the component.
\fIreply.sout()\fP has a filter installed, which translates
some characters, whith special meanings in html to the corresponding
html-entities.
The characters are <, >, &, " and '. This is useful for
printing values from variables to the html-code.
.PP
\fIqparam\fP holds the query-parameters parsed from GET- or POST-parameters
or received from other components.
The type of qparam is \fIcxxtools::query_params\fP.
Normally you use a <%args>-block to
specify the parameters, but there are special cases, where it is useful
to access these directly.
.
\" ---------------------------------------------------------------------
.SS component-adressing
\" ---------------------------------------------------------------------
Each component has a unique name.
The name is composed from the class-name, the character '@' and the
name of the shared library, it is located.
Components can have internal subcomponents.
The name of the internal subcomponent is appended to the classname
separated by a dot (.).
.
\" ---------------------------------------------------------------------
.SS special rule for line feeds after a </%something>-tag
\" ---------------------------------------------------------------------
A line feed immediately after a closing tag for all <%something>-blocks
are ignored. Hence blocks followed immediately one after another does
not generate white space in output, which is often undesirable.
.
\" ---------------------------------------------------------------------
.SS error-handling
\" ---------------------------------------------------------------------
Error-handling is done by exception.
Tntnet catches all exceptions thrown by components and handles them
properly.
Exceptions must be derived from std::exception.
Exceptions derived from tnt::HttpError, are handled separately.
They carry a http-return-code, which is sent to the client.
Other exceptions derived from std::exception, result in a http-error
code 500 (Internal Server Error).
.
\" =====================================================================
.SH TAGS
\" =====================================================================
.
\" ---------------------------------------------------------------------
.SS <$ \fIexpr\fP $>
\" ---------------------------------------------------------------------
Print expressions \fIexpr\fP to the outputstream.
The characters <, >, &, " and ', which have special meanings in html, are
translated to the corresponding html-entities.
.
\" ---------------------------------------------------------------------
.SS <$$ \fIexpr\fP $>
\" ---------------------------------------------------------------------
Print expressions \fIexpr\fP without translating characters with special
meaning in html to html-entities to the output-stream.
.
\" ---------------------------------------------------------------------
.SS <? \fIcond\fP ? \fIexpr\fP ?>
\" ---------------------------------------------------------------------
Conditional output.
Print expression \fIexpr\fP to the outputstream, if \fIcond\fP evaluates
to true. Characters with special meaning in html are translated to the
corresponding html-entities.
.
\" ---------------------------------------------------------------------
.SS <?? \fIcond\fP ? \fIexpr\fP ?>
\" ---------------------------------------------------------------------
Conditional output.
Print expression \fIexpr\fP to the outputstream, if \fIcond\fP evaluates
to true. Characters with special meaning in html are not translated to the
corresponding html-entities.
.
\" ---------------------------------------------------------------------
.SS <& \fIcomponent\fP [ arguments ] >
\" ---------------------------------------------------------------------
Call the specified component.
The output of the component is printed into the outputstream.
If the component-name does not start with a letter, the ecpp-compiler
treats it as a expression, which returns the name of the component.
You must surround the expression in brackets, if it contains spaces.
.PP
The arguments-part specify the parameters, the component will receive.
Arguments are names-value-pairs separated by '='.
They are put in the qparam-parameter of the component and are normally
declared in the <%args>-block.
Values can be specified in 3 forms:
.IP
As a plain word without spaces
.IP
As a string enclosed in quotation marks
.IP
As a expression enclosed in brackets
.PP
A single plain word in the argumentlist
is treated as a variable of type
.I cxxtools::query_params
and a copy is passed to the component. Other parameters are added to this copy.
If you want to pass all parameters of the current component put the
variable
.I qparam
as a plain word in the argument list.
.
.
\" ---------------------------------------------------------------------
.SS </&\fIcomponent\fP>
\" ---------------------------------------------------------------------
Closing-tag for a component-call.
When components are called, this closing-tag might occur later.
The code in <%close>-block is placed here.
.
\" ---------------------------------------------------------------------
.SS <{...}>
\" ---------------------------------------------------------------------
C++-inline-processing-block.
The code in this block is copied into the C++-class unchanged.
.PP
A linefeed after the closing tag is not ignored.
.
\" ---------------------------------------------------------------------
.SS <#...#>
\" ---------------------------------------------------------------------
Comment-block.
Everything in this block is ignored.
.
\" ---------------------------------------------------------------------
.SS <%application [ scope="component|page|global"] >...</%application>
\" ---------------------------------------------------------------------
Variables defined here, have the lifetime of the application.
.PP
Application-scope is automatically locked.
.
\" ---------------------------------------------------------------------
.SS <%args>...</%args>
\" ---------------------------------------------------------------------
Defines GET- or POST-parameters recieved by the component.
.PP
Each argument has a name and optionally a defaul-value.
The default-value is delimited by '=' from the name.
A single argument-definition followed by a semicolon (;).
In the component a variable with the same name of type std::string is defined,
which receives the value.
.PP
A argument-name can be prefixed by a type-definition.
The ecpp-compiler generates code, which tries to convert the value with
the input-stream-operator.
This means, that each type, which can be read from a input-stream (std::istream) can be used.
If the argument can't be converted, a exception is thrown.
.PP
Argumentnames can be postfixed by empty square-brackets.
This defines a std::vector with the specified type or std::string, if no type
is specified.
This way multiple values with the same name can be received.
If a type is specified, each value is converted to the target-type.
.
\" ---------------------------------------------------------------------
.SS <%close>...</%close>
\" ---------------------------------------------------------------------
Code in these tags is placed into the calling component, when a closing
tag </&\fIcomponent\fP> is found.
.PP
The <%close> receives the same parameters like the corresponding
normal component call.
.
\" ---------------------------------------------------------------------
.SS <%config>...</%config>
\" ---------------------------------------------------------------------
Often webapplications need some configuration like database-names
or login-information to the database.
These configuratioin-variables can be read from the \fItntnet.conf\fP.
Variablenames ended with a semicolon are defined as static
std::string-variables and filled from tntnet.conf. A variable can be
prepended by a type. The value from tntnet.conf is then converted
with a std::istream.
.PP
You can also specify a default value by appending a '=' and the value to
the variable.
.PP
.B Example:
.PP
.RS
.br
<%config>
.br
dburl = "sqlite:db=mydbfile.sqlite";
.br
int maxvalue = 10;
.br
</%config>
.RE
.PP
.B tntnet.conf:
.RS
dburl = "postgresql:dbname=mydb";
.RE
.
\" ---------------------------------------------------------------------
.SS <%cpp>...</%cpp>
\" ---------------------------------------------------------------------
C++-processing-block.
The code between these tags are copied into the C++-class unchanged.
.PP
A linefeed after the closing tag is ignored.
.
\" ---------------------------------------------------------------------
.SS <%def \fIname\fP>...</%def>
\" ---------------------------------------------------------------------
Defines a internal subcomponent with the name \fIname\fP, which
can be called like other components.
.
\" ---------------------------------------------------------------------
.SS <%doc>...</%doc>
\" ---------------------------------------------------------------------
Comment-block.
Everything in this block is ignored.
.PP
A linefeed after the closing tag is ignored.
.
\" ---------------------------------------------------------------------
.SS <%i18n>...</%i18n>
\" ---------------------------------------------------------------------
Encloses a block of text-data, which is to be translated.
See ecppl(1) and ecppll(1) for details.
.
\" ---------------------------------------------------------------------
.SS <%include>\fIfilename\fP</%include>
\" ---------------------------------------------------------------------
The specified file is read and compiled.
.
\" ---------------------------------------------------------------------
.SS <%param>...</%param>
\" ---------------------------------------------------------------------
Defines parameter received from calling components.
In contrast to query-parameters these variables can be of any type. The
syntax (and the underlying technology) is the same like in scoped
variables. See the description about scoped variables to see how to
define parameters.
The main difference is, that a parameter variable has no scope, since
the parameter is always local to the component.
.
\" ---------------------------------------------------------------------
.SS <%out> \fIexpr\fP </%out>
\" ---------------------------------------------------------------------
Same as <$$ ... $>. Prints the contained C++ expression \fIexpr\fP.
.
\" ---------------------------------------------------------------------
.SS <%pre>...</%pre>
\" ---------------------------------------------------------------------
Defines C++-code, which is placed outside the C++-class and outside the
namespace-definition.
This is a good place to define #include-directives.
.
\" ---------------------------------------------------------------------
.SS <%request [ scope="component|page|global"] >...</%request>
\" ---------------------------------------------------------------------
Define request-scope variables.
Variables defined here, has the lifetime of the request.
.
\" ---------------------------------------------------------------------
.SS <%session [ scope="component|page|global"] >...</%session>
\" ---------------------------------------------------------------------
Variables defined here, has the lifetime of the session.
.PP
Sessions are identified with cookies. If a <%session>-block is defined
somewhere in a component, a session-cookie is sent to the client.
.PP
Sessions are automatically locked.
.
\" ---------------------------------------------------------------------
.SS <%sout> \fIexpr\fP </%sout>
\" ---------------------------------------------------------------------
Same as <$ ... $>. Prints the contained C++ expression \fIexpr\fP.
The characters <, >, &, " and ', which have special meanings in html, are
translated to the corresponding html-entities.
.
\" ---------------------------------------------------------------------
.SS <%thread [ scope="component|page|global"] >...</%thread>
\" ---------------------------------------------------------------------
Variables defined here, has the lifetime of the thread.
Each thread has his own instance of these variables.
.PP
Thread-scope-variables do not need to be locked at all, because they
are only valid in the current thread.
.
\" =====================================================================
.SH SCOPED VARIABLES
\" =====================================================================
Scoped variables are c++-variables, whose lifetime is handled by tntnet.
These variables has a lifetime and a scope. The lifetime is defined by
the tag, used to declare the variable and the scope is passed as a
parameter to the tag.
.PP
There are 5 different lifetimes for scoped variables:
.RS
.TP
.I request
The variable is valid in the current request. The tag is \fI<%request>\fP.
.TP
.I application
The variable is valid in the application. The tag is \fI<%application>\fP.
The application is specified by the shared-library of the top-level component.
.TP
.I session
The variable is valid for the current session. The tag is \fI<%session>\fP.
If at least session-variable is declared in the current request, a
session-cookie is sent to the client.
.TP
.I thread
The variable is valid in the current thread. The tag is \fI<%thread>\fP.
.TP
.I param
The variable receives parameters. The tag is \fI<%param>\fP.
.RE
.sp
And 3 scopes:
.RS
.TP
.I component
The variable is only valid in the same component.
This is the default scope.
.TP
.I page
The variable is shared between the components in a single ecpp-file.
You can specify multiple internal subcomponents in a %def-block.
Variables, defined in page-scope are shared between these subcomponents.
.TP
.I global
Variables are shared between all components. If you define the same
variable with global-scope in different components, they must have the
same type. This is achieved most easily defining them in a separate
file and include them with a <%include>-block.
.TP
.RE
.PP
Variables are automatically locked as needed.
If you use session-variables, tntnet ensures, that all requests of the
same session are serialized.
If you use application-variables, tntnet serializes all requests to the
same application-scope.
Request- and thread-scope variables do not need to be locked at all,
because they are not shared between threads.
.SS Syntax of scoped variables
Scoped variables are declared with exactly the same syntax as normal
variables in c++-code. They can be of any type and are instantiated,
when needed. Objects, which do not have default constructors, need
to be specified with proper constructor-parameters in brackets or
separated by '='. The parameters are only used, if the variable need to
be instantiated. This means, that parameters to e.g. application-scope
variables are only used once. When the same component is called later
in the same or another request, the parameters are not used any more.
.SS Examples
.RS
<%application>
.br
unsigned count = 0;
.br
</%application>
.br
.RE
.sp
Specify a application-specific global variable, which is initialized
with 0.
.PP
.RS
<%session>
.br
MyClass sessionState;
.br
</%session>
.br
.RE
.sp
Specify a variable with a user-defined type, which holds the state of
the session.
.PP
.RS
<%thread scope="global">
.br
tntdb::Connection conn(dburl);
.br
</%thread>
.br
.RE
.sp
Specify a persistent databaseconnection, which is initialized, when
first needed and hold for the lifetime of the current thread. This
variable may be used in other components.
.PP
.
\" =====================================================================
.SH AUTHOR
\" =====================================================================
.
This manual page was written by Tommi M\[:a]kitalo <tommi@tntnet.org>.
.
\" =====================================================================
.SH SEE ALSO
\" =====================================================================
.
.BR tntnet (1),
.BR ecppc (1),
